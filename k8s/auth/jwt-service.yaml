---
# JWT 인증 서비스 - API용 토큰 발급/검증
apiVersion: v1
kind: ConfigMap
metadata:
  name: jwt-service-app
  namespace: infra
data:
  app.py: |
    #!/usr/bin/env python3
    from flask import Flask, request, jsonify
    import jwt
    import os
    import datetime

    app = Flask(__name__)
    JWT_SECRET = os.environ.get('JWT_SECRET', 'change-me-in-production')
    JWT_ALGORITHM = 'HS256'
    JWT_EXPIRATION_HOURS = 24

    @app.route('/health', methods=['GET'])
    def health():
        return jsonify({'status': 'healthy'}), 200

    @app.route('/auth/token', methods=['POST'])
    def generate_token():
        """JWT 토큰 발급 - OAuth2 인증 후 호출"""
        try:
            # OAuth2 Proxy에서 전달된 헤더 확인
            email = request.headers.get('X-Auth-Request-Email')
            user = request.headers.get('X-Auth-Request-User')

            if not email and not user:
                # OAuth2 인증이 안 된 경우, 요청 바디에서 확인 (테스트용)
                data = request.get_json() or {}
                email = data.get('email')
                user = data.get('user', email)

            if not email:
                return jsonify({'error': 'Unauthorized - No email provided'}), 401

            # JWT 페이로드 생성
            payload = {
                'email': email,
                'user': user,
                'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=JWT_EXPIRATION_HOURS),
                'iat': datetime.datetime.utcnow()
            }

            # JWT 토큰 생성
            token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)

            return jsonify({
                'token': token,
                'expires_in': JWT_EXPIRATION_HOURS * 3600,
                'token_type': 'Bearer'
            }), 200

        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @app.route('/auth/verify', methods=['GET', 'POST'])
    def verify_token():
        """JWT 토큰 검증"""
        try:
            # Authorization 헤더에서 토큰 추출
            auth_header = request.headers.get('Authorization', '')

            if not auth_header.startswith('Bearer '):
                return jsonify({'error': 'Invalid authorization header'}), 401

            token = auth_header.split(' ')[1]

            # JWT 토큰 검증
            payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])

            return jsonify({
                'valid': True,
                'email': payload.get('email'),
                'user': payload.get('user'),
                'exp': payload.get('exp')
            }), 200

        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except jwt.InvalidTokenError as e:
            return jsonify({'error': f'Invalid token: {str(e)}'}), 401
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @app.route('/auth/refresh', methods=['POST'])
    def refresh_token():
        """JWT 토큰 갱신"""
        try:
            auth_header = request.headers.get('Authorization', '')

            if not auth_header.startswith('Bearer '):
                return jsonify({'error': 'Invalid authorization header'}), 401

            token = auth_header.split(' ')[1]

            # 기존 토큰 디코드 (만료 검증 제외)
            payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM], options={'verify_exp': False})

            # 새 토큰 생성
            new_payload = {
                'email': payload.get('email'),
                'user': payload.get('user'),
                'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=JWT_EXPIRATION_HOURS),
                'iat': datetime.datetime.utcnow()
            }

            new_token = jwt.encode(new_payload, JWT_SECRET, algorithm=JWT_ALGORITHM)

            return jsonify({
                'token': new_token,
                'expires_in': JWT_EXPIRATION_HOURS * 3600,
                'token_type': 'Bearer'
            }), 200

        except Exception as e:
            return jsonify({'error': str(e)}), 500

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=5000)

  requirements.txt: |
    Flask==3.0.0
    PyJWT==2.8.0

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jwt-service
  namespace: infra
  labels:
    app: jwt-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jwt-service
  template:
    metadata:
      labels:
        app: jwt-service
    spec:
      initContainers:
      - name: install-dependencies
        image: python:3.11-alpine
        command: ['sh', '-c']
        args:
        - |
          pip install --no-cache-dir -r /app/requirements.txt -t /packages
        volumeMounts:
        - name: app-code
          mountPath: /app
        - name: python-packages
          mountPath: /packages
      containers:
      - name: jwt-service
        image: python:3.11-alpine
        command: ['sh', '-c']
        args:
        - |
          export PYTHONPATH=/packages:$PYTHONPATH
          python /app/app.py
        env:
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: jwt-secrets
              key: jwt-secret
        - name: FLASK_ENV
          value: "production"
        ports:
        - containerPort: 5000
          name: http
          protocol: TCP
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          limits:
            cpu: 200m
            memory: 256Mi
          requests:
            cpu: 100m
            memory: 128Mi
        volumeMounts:
        - name: app-code
          mountPath: /app
        - name: python-packages
          mountPath: /packages
      volumes:
      - name: app-code
        configMap:
          name: jwt-service-app
      - name: python-packages
        emptyDir: {}

---
apiVersion: v1
kind: Service
metadata:
  name: jwt-service
  namespace: infra
  labels:
    app: jwt-service
spec:
  type: ClusterIP
  ports:
  - port: 5000
    targetPort: 5000
    protocol: TCP
    name: http
  selector:
    app: jwt-service

---
# JWT Service Ingress - API 엔드포인트
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: jwt-service-ingress
  namespace: infra
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: api.son.duckdns.org
    http:
      paths:
      - path: /auth
        pathType: Prefix
        backend:
          service:
            name: jwt-service
            port:
              number: 5000
